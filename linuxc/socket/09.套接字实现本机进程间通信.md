实现方式有两种  
#### 第1种：使用网络套接字
比如使用TCP/IP协议族来实现，不管是使用TCP还是使用UDP都可以，只要将目标ip指定为本机IP或者127.0.0.1回环地址，即可实现本机进程间的通信

事实上使用实现网络通信的“网络套接字”来实现本机进程间通信，有点大材小用了，如果想要使用套接字来实现本机进程间通信的话，我们应该是使用“域套接字”，而不是“网络套接字”。

> 实现本机进程间通信，“域套接字”的效率会高于“网络套接字”。


#### 第2种：使用“域套接字”
创建“套接字文件时”，如果指定的是“域通信协议族”的话，这个套接字文件就被称为“域套接字文件”，简称域套接字。

> 域套接字不能实现跨进程间通信，只能用来实现“本机进程间通信”，而且还是专业的"本机间通信"

##### 到目前为止，本机进程间通信的方式有下面几种
* 1）信号
* 2）管道（无名、有名）
* 3）system V IPC（消息队列、共享内存、无名信号量）
* 4）域套接字



#### 域套接字的实现

有两种，分别是      
* 字节流的“域套接字”
* 数据报的“域套接字”


##### 1 字节流“域套接字”

* （1）编程模型
编程模型与TCP的编程模型完全一样。   
虽然编程模型与TCP一样，但是还是有所不同的，其中最大的不同就是，
绑定时设置的结构体是```struct sockaddr_un```，而不是 ```struct sockaddr_in```
```
struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[UNIX_PATH_MAX];	/* pathname */
};
```

设置这个结构体时，      
sun_family = AF_UNIX 或者 AF_LOCAL      
sun_path = 一个文件路径名//注意不是IP和端口，域套接字实现本机进程间通信时，用不到ip和端口。

bind绑定结构体的内容时，会创建“所设置路径名的”文件。

这个文件起到与ip和端口类似的作用



	
##### 2 数据报“域套接字”
（1）编程模型同UDP

bind时，设置的也是struct sockaddr_un，专门给“域通信协议族”使用的
```
struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[UNIX_PATH_MAX];	/* pathname */
};
```




