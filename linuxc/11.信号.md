
### 信号：OS提供的一种软件层面的通信机制
#### 1. 什么是信号     
* 信号是一种通知进程某件事情发生了的一种简单通信机制，通过向进程发送某个信号，可以告诉进程发生了什么事情，进程收到这个信号后 就知道某事情发生了，进程可以做出相应的响应（处理），所以其实信号也是一种通信机制，目的就是用于告诉进程发生了什么事情   
* 不过Linux所实现的信号这种通信机制，与IPC（进程间通信）所不同的是，信号属于不精确通信，信号只能告诉进程大概发生了什么事情，但是不能准确的告诉进程详细的细节信息          
　　
　这就好比以前长城放狼烟是一样的，放狼烟就是一种信号，只能告诉你敌人来了，大概来了多少人，但是无法告诉更多更详细的情报        
　　但是如果是电话、电报的话，就属于精确通信，不仅可以告诉你敌人来了，还会告诉你敌军的详细情况

* 是不是有了精确的IPC后，就可以将信号淘汰了呢？显然不是的，信号有自己应用场合	

#### 2.信号的命名
　　Linux下边定义了很多的信号，所有的信号都是一个整数编号，不过为了好辨识，Linux系统给这些整数编号都定义了对应的宏名       
　　宏名都是以SIG开头，比如SIGABRT             
　　SIG：signal的缩写                                   
　　ABRT：abort的缩写                          
　　宏名SIG***，***是对信号的描述，ABRT表示放弃的意思，向进程发送SIGABRT信号，进程会被信号异常终止      
　　当我们调用abort函数时，该函数就会向进程发送一个SIGABRT信号，你一看到ABRT就知道与abort函数有关系	

#### 3. 谁会向进程发送信号
　　总结起来，会有三个“人”会向进程发送信号，分别是'另一进程'、'OS内核'、'硬件'(键盘，鼠标通过内核中转)
　
* (1)另一个进程发送信号
```
　　比如在命令行终端窗口通过kill命令向某个进程发送一个信号将其终止	
　　开2个shell窗口 ps查看pid
　　一个去杀死另外一个
　　kill -9 PID	
```
* (2)内核发送信号
```
　发生了某个事件，Linux内核可能会发送该事件对应的信号给某个进程
　进程从管道文件读取数据，但是管道文件的读权限被关闭了，
　进程会被内核发送一个SIGPIPE信号，提示读管道出错了详见后面讲进程间通信
```
* (3)底层硬件发送信号
```
　底层硬件发生了某个事件，会向进程发送对应的某个信号
　　比如按下ctrl+c按键终止进程时，内核收到ctrl+c按键后，会向正在运行的进程发送SIGINT信号，将其异常终止
　　不管进程是被哪一个信号给终止了，只要是被信号终止的，都是异常终止
```

#### 4.进程收到信号后，进程会如何处理
　　三种处理方式，分别是忽略、捕获、默认            
* 4.1 忽略          
　　忽略的意思就是说，进程就当信号从来没有发生过<br>
　　这就好比别人送了封信给你，但是你忽略这封信的存在，那么这封信将不会对你产生任何影响
* 4.2 捕获  
　　捕获的意思就是说，进程会调用相应的处理函数，进行相应的处理
* 4.3 默认              
　　如果不忽略也不捕获的话，此时进程会使用系统设置的默认处理方式来处理信号

#### 5. 都有哪些信号
>　kill -l

* 5.1 信号列表
```
1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

```
在命令行执行kill -l，可以显示所有的信号列表         
　　总共62个信号，也就是说每个进程可以接收的信号种类有62种，1~64为信号的编号，SIG***为信号的宏名
　　
* 为什么这么多信号？     
　　每个信号代表着某种事件，一般情况下，当进程收到某个信号时，就表示该信号所代表的事件发生了。  
　　可能发生的事件会有很多种，所以弄出了这么多的信号，每个信号对应着自己特有的事件。	

    * (1)35~64：这些信号是Linux后期增设的信号，这些个信号不需要关心，所以不用了解
    * (2)1~34：也不是所有的信号都要掌握，我们只关心其中常用的信号
* 5.2常用信号

信号宏名|   信号编号        |   说明             |系统默认处理方式 
--------|-------------------|--------------------|-----------
SIGABRT |        6          | 终止进程，调abort函数是产生               |  终止，产生core文件
SIGALRM |         14        |   超时,调用alarm函数时产生                |   终止
SIGBUS  |        7          |   硬件故障                                |    终止，产生core文件
SIGCHLD |           17      |   子进程状态改变(执行态到终止态  )        | 忽略
SIGINT  |          2        |   终止进程（ctrl+c）                      |   终止
SIGIO   |         29        |   异步通知信号                            | 终止        
SIGKILL |            9      |    无条件终止一个进程,不可以被捕获或忽略  |  终止
SIGPIPE |          13       |   写没有读权限的管道文件时                |  终止
SIGPOLL |          8        |    轮询事件，涉及POLL机制                 |  终止                
SIGQUIT |          3        |    终止进程（ctrl+\）                     |  终止，产生core文件
SIGSEGV |          11       |    无效存储访问（指针错误）               |终止，产生core文件 
SIGTERM |          15       |   终止，kill PID时，默认发送的就是这个信号| 终止        
SIGUSR1 |         10        |    用户自定义信号1                        |   终止    
SIGUSR2 |        12         |    用户自定义信号2                        |   终止

> 为什么当进程收到某些信号时，会被终止呢？
* 比如ctrl+c发送SIGINT给进程时
* 比如操作一个错误地址，内核发送SIGSEGV信号给进程时
* 比如ctrl+\发送SIGQUIT信号给进程时
* 比如在命令行使用kill pid，默认发送SIGTERM信号给进程时
> 因为你发送的这些信号的处理方式是终止，所以进程会被终止掉

### kill命令
#### 1）kill的作用

##### （a）kill -l：查询信号列表

##### （b）通过PID向进程发送一个信号

　　kill只是发送信号，至于进程会不会被终止，这就看信号的处理方式，处理方式如果是终止，那么就会终止进程        
　　所以进程是否会被信号终止，是由信号的处理方式来决定的，

发送信号的完整格式：kill -信号编号 PID          
* 信号编号写数字和宏名都可以      
* 如果不写明信号编号的话：kill PID，默认发送的是15(SIGTERM)信号，等价于kill -SIGTERM PID或者kill -15 PID
* 只有发送15这个信号时才能省略信号编号，发送其它信号时必须写明信号编号

##### （c）为什么kill发送15(SIGTERM)这个信号时，信号编号可以省略？    
　　我们说每个信号都有自己的特有用途，当初定义15（SIGTERM）信号的目的，就是专门给我们从命令行终端窗口，
　　发送该信号去终止某个进程用的，也就是说如果你想在命令行使用kill命令去中断某个进程时，专用信号就是15      
　　其实一般只要默认处理方式是终止的信号，我们都可以使用Kill命令将其发送给某个进程，这些信号都可以将进程终
　　止掉，但是既然每个信号有自己的专门用途，那么在命令行去终止某个进程时，我们最好是使用专门的SIGTERM信号，
　　这样显得更专业些        
　　为了方便我们使用，Linux允许发送15这个信号时，不用设置信号编号，kill pid时会帮你默认发送这个信号	
#### 2）pkill
　　kill命令的兄弟，用法与kill差不多，只不过kill是按照PID来识别进程的，pkill是按照名字来识别进程的  
　　pkill -信号编号 名字    
　　pkill -SIGINT a.out     
　　同样的，如果不写明信号编号的话，默认发送的是15(SIGTERM)这个信号
#### 3）信号的发送与接收
##### 1）发送     
　　一般来说，大多数发送信号的原因，都是因为内核、硬件发生了某些事件时，才会向某个进程发送该事件专用的信号，告诉该进程这个事件发生了      
　　不过对于我们自己写的进程来说，其实更多是接收信号，而不是发送信号    
###### 我们自己发送信号的原因无非如下几种情况：
* （a）ctrl+C、ctrl+\发送信号，终止正在运行进程
* （b）命令行执行kill命令发送信号，终止跑飞的进程，通常都是发送15这个信号      
　　15这个信号的名字叫SIGTERM，TERM就是terminal的缩写，其实就是命令行终端的意思    
　　当无法使用ctrl+c、ctrl+\来终止进程时，往往就使用kill命令来终止进程<br>
那么什么样的进程会使用crtl+c、ctrl+\来终止？    
　　只有当进程有占用命令行终端时，才能crtl+c、ctrl+\来终止
* （c）因为某些特殊需求，往往在我们自己的程序里面，需要调用kill函数向另一个进程发送某个信号    
　　比如A进程和B进程需要协同工作，A进程将相应事件准备好以后，可能需要发送一个信号给B进程，通知B进程,B进程收到信号后，就知道该事件已经准备好，可以配合A进程做事了                   
　　
至于说自己写的进程发送什么信号合适呢？          
　　其实发送哪一种信号都行，但是我们说几乎每一种信号都有自己特定的用途  
　　所以我们自己的程序在发送信号时，如果发送别人专用事件的信号的话，这样显得很不正规，而且很可能造成误会    
　　比如我的A进程给另一个进程发送了一个SIGSEGV信号，B进程还以为发生了指针错误事件，其实发生并不是指针错误事件，而是其它事件，这就造成了理解的错误。    
　　因此自己进程调用kill函数发送信号时，我们可以发送的是SIGUSR1、SIGUSR2这两个自定义信号，所谓自定义就是，信号所代表的事件，可以由程序员自己根据实际情况来规定。	

#### 2）接收
　　对于我们自己写的进程来说，最常见信号操作的还是接收信号，不过在一般情况下，我们进程并不会去重新设置信号的处
　　理方式，而是使用信号的默认处理方式来处理信号。虽然很少重新设置信号的处理方式，但是总还是有这种需求的


### core文件
#### 1）什么是core文件   
　　用于保存程序（进程）在当前结束的这一刻，进程在内存中的代码和数据，core文件可以用于分析进程在结束时的状况    
　　不过由于进程代码和数据都是二进制的，所以把core文件直接打开后我们是看不懂的，一般需要特殊软件翻译后才能看懂  
#### 2）并不是所有的信号在终止进程时都会产生core文件
　　只有某个些信号在终止进程时才会产生core文件，不过一般情况下并不会创建这个文件，因为系统默认将产生core的设置给关闭了，只有打开后这个设置后才会保存core文件    
　　所以当你看到提示core dumped，这就表示这个信号终止进程时，会产生core文件，只不过由于关闭了设置，因此core文件被丢弃了，dumped就是丢弃的意思

* 1：crtl+\ 发送SIGQUIT信号
* 2：操作错误地址

#### 3）如果你不想丢弃core文件怎么办？
　　对相关的系统文件进行设置就可以了，core文件一般默认保存在当前路径下    
　
　　由于core在实际开发中基本用不到（除非某些很特殊的场合）

















