## 进程控制
#### 多进程并发运行       
在os支持时，会有很多的进程在运行，这些进程都是并发运行的

#### 并发运行:    就是cpu轮换的执行，当前进程执行了一个短暂的时间片(ms)后，切换执行另一进程，如此循环往复
* 由于时间片很短,在宏观上我们感觉到所有的进程都是在同时运行的，但是在微观上cpu每次只执行某一个进程的指令
* 如果是多核cpu的情况,如果cpu是多核的话，不同的cpu核可以同时独立的执行不同的进程，这种叫并行运行
* 所以当cpu是多核时,并发与并行是同时存在的
### 进程id
唯一，如果当前进程结束了,这个pid可以被重复使用，但是，所有活着的进程，它们的进程id一定是唯一的

### 操作系统运行起来后会有三个特殊进程启动，他们的pid分别是0,1,2
os启动后他们一直默默运行，直到os结束关机

#### 1.pid=0的进程
* 1)作用:
    * 这个进程被称为调度进程，功能是实现进程间的调度和切换
    * 改进程根据调度算法，该进程会让cpu轮换的执行所有的进程
    * 当pc指向不同的进程时，cpu就去执行不同的进程，这样就能实现切换
* 2)来源    
　　这个进程就是os演变来的，os启动后，最后有一部分代码会持续运行，这个就是pid=0的进程
　　由于这个进程时os的一部分，凡是由os代码演变来的进程，都称之为系统进程
#### 2.pid=1的进程                   
   * 1)作用
        * 作用1:初始化  
这个进程被称为Init进程，它会读取各种各样的系统文件，使用文件中的数据来初始化os的启动,让os进入多用户状态，也就是让os支持多用户的登录
　　　　
        * 作用2:托管孤儿进程
        * 作用3:原始父进程
![](https://note.youdao.com/yws/api/personal/file/29E723EE6BB14B9594B3B7A5D4C2D2C0?method=download&shareKey=30319b1b97cf09725ce1c1d19c59b943)    
* 2)这个进程怎么运行起来的                    
　　这个进程不是os演变来的，也就是说这个进程的代码不属于os的代码，这个进程是一个独立的进程，程序代码放在了/sbin/init下,当os启动起来后，os会执行init操作，将它的代 码加载到内存，这个进程就运行起来了

#### 3.pid=2的进程
* 1)作用:                                                             
    * 页精灵进程，专门负责虚拟内存的请页操作
    * 精灵进程:也叫守护进程
    * 换页操作:<br>
    当os支持虚拟内存机制时，加载应用程序到内存时，并不会进行完整的代码拷贝，只会拷贝当前要运行的那部分代码，
当这部分代码运行完毕以后，会再拷贝另外一部分需要运行的代码到内存中，拷贝时是按照一页一页来操作的每一页大概4096字节
* 2)这个进程与调度进程一样，也是一个系统进程，代码属于os的一部分